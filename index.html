<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MP3 キーチェンジャー</title>

<style>
  body{font-family:sans-serif;margin:0;padding:20px 20px 70px;}
  #playlist{margin-top:10px;max-height:35vh;overflow:auto;border:1px solid #ccc;padding:4px;}
  .track{cursor:pointer;margin-bottom:5px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
         padding:2px 4px;border-bottom:1px solid #eee;}
  .track.selected{font-weight:bold;color:blue;}

  .controls,.sliders{margin-top:20px;}
  input[type=range]{width:100%;}
  .inline-label{display:flex;align-items:center;gap:8px;}
  .key-control-buttons{display:flex;gap:8px;align-items:center;}
  .time-display{margin-top:10px;font-size:14px;color:#333;}

  .loading-overlay{position:fixed;inset:0;background:rgba(255,255,255,.8);
    display:none;justify-content:center;align-items:center;font-size:20px;font-weight:bold;z-index:999;}

  footer{position:fixed;inset-block-end:0;inset-inline:0;background:#f2f2f2;
    border-top:1px solid #ccc;padding:10px 20px;font-size:14px;color:#666;
    display:flex;justify-content:space-between;align-items:center;}

  @media(max-width:600px){
    body{padding:10px 10px 70px;}
    button{font-size:16px;padding:10px;width:100%;margin-bottom:10px;}
    .inline-label{flex-direction:column;align-items:flex-start;}
  }
</style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">読み込み中...</div>

  <!-- Media Session API を使えばロック画面操作も可能です（iOS 15+） -->
  <input type="file" id="fileInput" multiple accept=".mp3,audio/mpeg">
  <div id="playlist"></div>

  <div class="controls">
    <button onclick="playAudio()">再生</button>
    <button onclick="pauseAudio()">一時停止</button>
    <button onclick="stopAudio()">停止</button>
    <button onclick="nextTrack()">次の曲へ</button>
    <button onclick="toggleShuffle()">シャッフル: <span id="shuffleState">OFF</span></button>
  </div>

  <div class="sliders">
    <label class="inline-label">キー変更（半音）:
      <div class="key-control-buttons">
        <button onclick="adjustPitch(-1)">−</button>
        <input type="range" id="pitchSlider" min="-12" max="12" step="1" value="0">
        <button onclick="adjustPitch(1)">＋</button>
        <span id="pitchValue">0</span>
      </div>
    </label>

    <label>再生位置:
      <input type="range" id="seekSlider" min="0" max="1" step="0.01" value="0">
    </label>

    <div class="time-display" id="timeDisplay">--:-- / --:--</div>
  </div>

  <!-- バックグラウンド再生用 audio（playsinline でフルスクリーン抑止） -->
  <audio id="htmlAudio" preload="auto" playsinline style="display:none"></audio>

  <footer>
    <span id="metaInfo">プレイリスト: 0 曲</span>
    <span id="playStatus">未再生</span>
    <span class="version">v1.8</span>
  </footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.js"></script>
  <script>
/* ───── DOM & 変数 ───── */
const htmlAudio  = document.getElementById('htmlAudio');
const playStatus = document.getElementById('playStatus');
const timeDisp   = document.getElementById('timeDisplay');
const seekSlider = document.getElementById('seekSlider');
const loadingLay = document.getElementById('loadingOverlay');
const metaInfo   = document.getElementById('metaInfo');
const fileInput  = document.getElementById('fileInput');

let playlist=[], currentIndex=-1, shuffle=false, timer=null;
let mediaSrc=null, pitchShift=null;

/* ───── 共通 ───── */
const showLoading = f=>loadingLay.style.display=f?'flex':'none';
const fmt=s=>isNaN(s)?'--:--':`${String(Math.floor(s/60)).padStart(2,'0')}:${String(Math.floor(s%60)).padStart(2,'0')}`;

/* ───── ファイル読み込み ───── */
fileInput.addEventListener('change', e=>{
  if(!e.target.files.length){ fileInput.value=''; return; }
  Array.from(e.target.files).forEach(f=>{
    if(!playlist.some(p=>p.name===f.name)) playlist.push(f);
  });
  fileInput.value='';
  renderPlaylist();
});
function renderPlaylist(){
  const list=document.getElementById('playlist');
  list.innerHTML='';
  playlist.forEach((f,i)=>{
    const div=document.createElement('div');
    div.textContent=f.name;
    div.className='track'+(i===currentIndex?' selected':'');
    div.onclick=()=>loadAndPlay(i);
    list.appendChild(div);
  });
  metaInfo.textContent=`プレイリスト: ${playlist.length} 曲`;
}

/* ───── ピッチ変更 ───── */
document.getElementById('pitchSlider').addEventListener('input',e=>{
  if(pitchShift) pitchShift.pitch=parseInt(e.target.value);
  document.getElementById('pitchValue').textContent=e.target.value;
});
function adjustPitch(d){
  const s=document.getElementById('pitchSlider');
  s.value=Math.max(-12,Math.min(12,parseInt(s.value)+d));
  s.dispatchEvent(new Event('input'));
}

/* ───── AudioContext の自動復帰 ───── */
function ensureAudioContext(){
  if(Tone.context.state!=='running'){
    Tone.context.resume().catch(()=>{});
  }
}
document.addEventListener('visibilitychange', ensureAudioContext);
document.addEventListener('resume', ensureAudioContext);      // iOS PWA
htmlAudio.addEventListener('timeupdate', ensureAudioContext); // 保険

/* ───── 再生制御 ───── */
async function loadAndPlay(idx){
  if(!playlist.length) return;
  showLoading(true); stopAudio(false);

  currentIndex=idx; renderPlaylist();
  htmlAudio.src=URL.createObjectURL(playlist[idx]);

  await Tone.start();
  if(Tone.context.state==='suspended') await Tone.context.resume();

  /* AudioNodes (最初だけ生成) */
  if(!mediaSrc){
    mediaSrc = Tone.context.createMediaElementSource(htmlAudio);
    pitchShift = new Tone.PitchShift({
      pitch: parseInt(document.getElementById('pitchSlider').value)
    }).toDestination();
    mediaSrc.connect(pitchShift);
  }

  await htmlAudio.play();
  updateSeekBar();
  playStatus.textContent='再生中'; playStatus.style.color='green';
  showLoading(false);
}
function playAudio(){
  if(!htmlAudio.src) return;
  Tone.start().then(async()=>{
    if(Tone.context.state==='suspended') await Tone.context.resume();
    htmlAudio.play();
    playStatus.textContent='再生中'; playStatus.style.color='green';
  });
}
function pauseAudio(){
  htmlAudio.pause();
  playStatus.textContent='一時停止'; playStatus.style.color='orange';
}
function stopAudio(reset=true){
  htmlAudio.pause(); htmlAudio.currentTime=0;
  clearInterval(timer); seekSlider.value=0; timeDisp.textContent='--:-- / --:--';
  if(reset){ playStatus.textContent='停止'; playStatus.style.color='gray'; }
}
function nextTrack(){
  if(!playlist.length) return;
  const n = shuffle
    ? (playlist.length===1?currentIndex:(()=>{let r;do{r=Math.floor(Math.random()*playlist.length);}while(r===currentIndex);return r;})())
    : (currentIndex+1)%playlist.length;
  loadAndPlay(n);
}
function toggleShuffle(){
  shuffle=!shuffle;
  document.getElementById('shuffleState').textContent=shuffle?'ON':'OFF';
}
htmlAudio.addEventListener('ended', ()=>nextTrack());

/* ───── シークバー ───── */
seekSlider.addEventListener('input',e=>{
  if(!htmlAudio.duration) return;
  htmlAudio.currentTime=parseFloat(e.target.value);
});
function updateSeekBar(){
  clearInterval(timer);
  if(!htmlAudio.duration) return;
  seekSlider.max=htmlAudio.duration;

  const refresh=()=>{
    seekSlider.value=htmlAudio.currentTime;
    timeDisp.textContent=`${fmt(htmlAudio.currentTime)} / ${fmt(htmlAudio.duration)}`;
  };
  refresh(); timer=setInterval(refresh,500);
}
  </script>
</body>
</html>
