<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MP3 キーチェンジャー</title>
  <style>
    body { font-family: sans-serif; padding: 20px; margin-bottom: 80px; }
    h1 { font-size: 24px; }
    #playlist { margin-top: 10px; }
    .track { cursor: pointer; margin-bottom: 5px; }
    .track.selected { font-weight: bold; color: blue; }
    .controls, .sliders { margin-top: 20px; }
    input[type=range] { width: 100%; }
    .inline-label { display: flex; align-items: center; gap: 8px; }
    .status { margin-top: 10px; font-weight: bold; color: green; }
    .key-control-buttons { display: flex; gap: 8px; align-items: center; }
    .time-display { margin-top: 10px; font-size: 14px; color: #333; }
    .loading-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.8); display: none;
      justify-content: center; align-items: center;
      font-size: 20px; font-weight: bold; color: #333;
      z-index: 9999;
    }
    footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f2f2f2; padding: 10px 20px; border-top: 1px solid #ccc; text-align: center; font-size: 14px; color: #666; }
    @media (max-width: 600px) {
      body { padding: 10px; font-size: 16px; }
      h1 { font-size: 20px; }
      button { font-size: 16px; padding: 10px; width: 100%; margin-bottom: 10px; }
      .inline-label { flex-direction: column; align-items: flex-start; }
      input[type=range] { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">読み込み中...</div>
  <h1>クライアントサイド MP3 キーチェンジャー1.3</h1>

  <input type="file" id="fileInput" multiple accept="audio/mp3">
  <div id="playlist"></div>

  <div class="controls">
    <button onclick="playAudio()">再生</button>
    <button onclick="pauseAudio()">一時停止</button>
    <button onclick="stopAudio()">停止</button>
    <button onclick="nextTrack()">次の曲へ</button>
    <button onclick="toggleShuffle()">シャッフル: <span id="shuffleState">OFF</span></button>
    <div class="status" id="playStatus">未再生</div>
  </div>

  <div class="sliders">
    <label>音量調整:
      <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
    </label>

    <label class="inline-label">キー変更（半音）:
      <div class="key-control-buttons">
        <button onclick="adjustPitch(-1)">−</button>
        <input type="range" id="pitchSlider" min="-12" max="12" step="1" value="0">
        <button onclick="adjustPitch(1)">＋</button>
        <span id="pitchValue">0</span>
      </div>
    </label>

    <label>再生位置:
      <input type="range" id="seekSlider" min="0" max="1" step="0.01" value="0">
    </label>

    <div class="time-display" id="timeDisplay">--:-- / --:--</div>
  </div>

  <footer>クライアントサイドで安全に動作するMP3キーチェンジャー（β版）</footer>

  <!-- Tone.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.js"></script>
  <script>
/* -------------------- 変数 -------------------- */
let playlist = [];
let currentIndex = -1;
let playOrder = [];
let shuffle = false;
let player = null;
let pitchShift = null;
let updateInterval = null;
let isLoading = false;
let pausedOffset = 0;          // 一時停止中の再開位置

/* -------------------- DOM -------------------- */
const playStatus   = document.getElementById('playStatus');
const timeDisplay  = document.getElementById('timeDisplay');
const loadingLayer = document.getElementById('loadingOverlay');
const seekSlider   = document.getElementById('seekSlider');

/* -------------------- 共通 UI -------------------- */
function showLoading(on) {
  isLoading = on;
  loadingLayer.style.display = on ? 'flex' : 'none';
}
function formatTime(sec) {
  if (isNaN(sec)) return '--:--';
  const m = Math.floor(sec / 60).toString().padStart(2, '0');
  const s = Math.floor(sec % 60).toString().padStart(2, '0');
  return `${m}:${s}`;
}

/* -------------------- プレイリスト -------------------- */
document.getElementById('fileInput').addEventListener('change', e => {
  playlist   = Array.from(e.target.files);
  playOrder  = playlist.map((_, i) => i);
  currentIndex = -1;
  renderPlaylist();
});
function renderPlaylist() {
  const list = document.getElementById('playlist');
  list.innerHTML = '';
  playlist.forEach((file, idx) => {
    const div = document.createElement('div');
    div.textContent = file.name;
    div.className = 'track' + (idx === currentIndex ? ' selected' : '');
    div.onclick = () => loadAndPlay(idx);
    list.appendChild(div);
  });
}

/* -------------------- 音量・ピッチ -------------------- */
document.getElementById('volumeSlider').addEventListener('input', e => {
  if (player) player.volume.value = Tone.gainToDb(parseFloat(e.target.value));
});
document.getElementById('pitchSlider').addEventListener('input', e => {
  document.getElementById('pitchValue').textContent = e.target.value;
  if (pitchShift) pitchShift.pitch = parseInt(e.target.value);
});
function adjustPitch(step) {
  const slider = document.getElementById('pitchSlider');
  slider.value = Math.max(-12, Math.min(12, parseInt(slider.value) + step));
  slider.dispatchEvent(new Event('input'));
}

/* -------------------- シーク -------------------- */
seekSlider.addEventListener('input', e => {
  if (!player || !player.buffer) return;
  const dest = parseFloat(e.target.value);
  player.stop();
  player.start(undefined, dest);
  player._startedAt = Tone.now() - dest;   // ★ 再スタート時間を補正
  updateSeekBar();
});

/* -------------------- シャッフル -------------------- */
function toggleShuffle() {
  shuffle = !shuffle;
  document.getElementById('shuffleState').textContent = shuffle ? 'ON' : 'OFF';
}
function nextTrack() {
  if (!playlist.length) return;
  const nextIdx = shuffle
    ? (playlist.length === 1 ? currentIndex : (() => {
        let n;
        do { n = Math.floor(Math.random() * playlist.length); } while (n === currentIndex);
        return n;
      })())
    : (currentIndex + 1) % playlist.length;
  loadAndPlay(nextIdx);
}

/* -------------------- 再生制御 -------------------- */
async function loadAndPlay(index) {
  if (isLoading) return;
  showLoading(true);
  stopAudio();               // 既存プレーヤを完全破棄
  currentIndex = index;
  renderPlaylist();

  const file = playlist[index];
  const buffer = await Tone.context.decodeAudioData(await file.arrayBuffer());

  pitchShift = new Tone.PitchShift({ pitch: parseInt(document.getElementById('pitchSlider').value) }).toDestination();
  player = new Tone.Player(buffer).connect(pitchShift);
  player.volume.value = Tone.gainToDb(parseFloat(document.getElementById('volumeSlider').value));
  player.loop = false;

  player.onstop = () => {        // 曲の自然終了時のみ nextTrack()
    if (!isLoading && !pausedOffset) nextTrack();
  };

  await Tone.start();
  if (Tone.context.state === 'suspended') await Tone.context.resume();

  player.start();
  player._startedAt = Tone.now();   // ★ 再生開始時刻を保存
  pausedOffset = 0;
  updateSeekBar();

  playStatus.textContent = '再生中...';
  playStatus.style.color = 'green';
  showLoading(false);
}

function playAudio() {
  if (!player) return;
  Tone.start().then(() => {
    if (Tone.context.state === 'suspended') Tone.context.resume();

    const startAt = pausedOffset;   // 0 なら頭から
    player.start(undefined, startAt);
    player._startedAt = Tone.now() - startAt;
    pausedOffset = 0;

    updateSeekBar();
    playStatus.textContent = '再生中...';
    playStatus.style.color = 'green';
  });
}

function pauseAudio() {
  if (player && player.state === 'started') {
    pausedOffset = Tone.now() - player._startedAt;
    player.stop();
    playStatus.textContent = '一時停止中';
    playStatus.style.color = 'orange';
    clearInterval(updateInterval);
  }
}

function stopAudio() {
  if (player) {
    player.stop();
    player.dispose();
    player = null;
  }
  if (pitchShift) {
    pitchShift.dispose();
    pitchShift = null;
  }
  clearInterval(updateInterval);
  seekSlider.value = 0;
  seekSlider.max   = 1;
  timeDisplay.textContent = '--:-- / --:--';
  pausedOffset = 0;
  playStatus.textContent = '停止中';
  playStatus.style.color = 'gray';
}

/* -------------------- シークバー更新 -------------------- */
function updateSeekBar() {
  if (!player || !player.buffer) return;
  clearInterval(updateInterval);

  const duration = player.buffer.duration;
  seekSlider.max = duration;

  // ☆ まず 1 回即時更新
  const refresh = () => {
    const now   = Tone.now();
    const pos   = now - (player._startedAt || now);   // _startedAt が無い場合は 0
    if (pos >= duration) {
      seekSlider.value = duration;
      timeDisplay.textContent = `${formatTime(duration)} / ${formatTime(duration)}`;
      clearInterval(updateInterval);
      return;
    }
    seekSlider.value = pos;
    timeDisplay.textContent = `${formatTime(pos)} / ${formatTime(duration)}`;
  };
  refresh();

  updateInterval = setInterval(refresh, 500);
}
  </script>
</body>
</html>
