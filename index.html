<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MP3 キーチェンジャー</title>
  <style>
    body { font-family: sans-serif; padding: 20px; margin-bottom: 80px; }
    h1 { font-size: 24px; }
    #playlist { margin-top: 10px; }
    .track { cursor: pointer; margin-bottom: 5px; }
    .track.selected { font-weight: bold; color: blue; }
    .controls, .sliders { margin-top: 20px; }
    input[type=range] { width: 100%; }
    .inline-label { display: flex; align-items: center; gap: 8px; }
    .status { margin-top: 10px; font-weight: bold; color: green; }
    .key-control-buttons { display: flex; gap: 8px; align-items: center; }
    .time-display { margin-top: 10px; font-size: 14px; color: #333; }
    .loading-overlay {
      position: fixed; inset: 0;
      background: rgba(255,255,255,0.8); display: none;
      justify-content: center; align-items: center;
      font-size: 20px; font-weight: bold; color: #333;
      z-index: 9999;
    }
    footer { position: fixed; inset-block-end: 0; inset-inline: 0;
      background: #f2f2f2; padding: 10px 20px; border-top: 1px solid #ccc;
      text-align: center; font-size: 14px; color: #666; }
    @media (max-width: 600px) {
      body { padding: 10px; font-size: 16px; }
      h1 { font-size: 20px; }
      button { font-size: 16px; padding: 10px; width: 100%; margin-bottom: 10px; }
      .inline-label { flex-direction: column; align-items: flex-start; }
      input[type=range] { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">読み込み中...</div>
  <h1>クライアントサイド MP3 キーチェンジャー1.5</h1>

  <input type="file" id="fileInput" multiple accept="audio/mp3">
  <div id="playlist"></div>

  <div class="controls">
    <button onclick="playAudio()">再生</button>
    <button onclick="pauseAudio()">一時停止</button>
    <button onclick="stopAudio()">停止</button>
    <button onclick="nextTrack()">次の曲へ</button>
    <button onclick="toggleShuffle()">シャッフル: <span id="shuffleState">OFF</span></button>
    <div class="status" id="playStatus">未再生</div>
  </div>

  <div class="sliders">
    <label>音量調整:
      <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
    </label>

    <label class="inline-label">キー変更（半音）:
      <div class="key-control-buttons">
        <button onclick="adjustPitch(-1)">−</button>
        <input type="range" id="pitchSlider" min="-12" max="12" step="1" value="0">
        <button onclick="adjustPitch(1)">＋</button>
        <span id="pitchValue">0</span>
      </div>
    </label>

    <label>再生位置:
      <input type="range" id="seekSlider" min="0" max="1" step="0.01" value="0">
    </label>

    <div class="time-display" id="timeDisplay">--:-- / --:--</div>
  </div>

  <footer>クライアントサイドで安全に動作するMP3キーチェンジャー（β版）</footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.js"></script>
  <script>
/* ======== グローバル ======== */
let playlist = [], playOrder = [];
let currentIndex = -1, shuffle = false;
let player = null, pitchShift = null;
let updateInterval = null, isLoading = false;
let pausedOffset = 0;          // 一時停止中の再開位置
let ignoreStop = false;        // ← ★ 手動 stop 判定フラグ

/* ======== DOM ======== */
const playStatus   = document.getElementById('playStatus');
const timeDisplay  = document.getElementById('timeDisplay');
const seekSlider   = document.getElementById('seekSlider');
const loadingLayer = document.getElementById('loadingOverlay');

/* ======== 共通関数 ======== */
const showLoading = f => (isLoading = f, loadingLayer.style.display = f ? 'flex' : 'none');
const fmt = s => isNaN(s) ? '--:--' : `${String(Math.floor(s/60)).padStart(2,'0')}:${String(Math.floor(s%60)).padStart(2,'0')}`;

/* ======== プレイリスト読み込み ======== */
document.getElementById('fileInput').addEventListener('change', e => {
  playlist = Array.from(e.target.files);
  playOrder = playlist.map((_, i) => i);
  currentIndex = -1;
  renderPlaylist();
});
function renderPlaylist() {
  const list = document.getElementById('playlist');
  list.innerHTML = '';
  playlist.forEach((f, i) => {
    const div = document.createElement('div');
    div.textContent = f.name;
    div.className = 'track' + (i === currentIndex ? ' selected' : '');
    div.onclick = () => loadAndPlay(i);
    list.appendChild(div);
  });
}

/* ======== 音量・ピッチ ======== */
document.getElementById('volumeSlider').addEventListener('input', e => {
  if (player) player.volume.value = Tone.gainToDb(parseFloat(e.target.value));
});
document.getElementById('pitchSlider').addEventListener('input', e => {
  document.getElementById('pitchValue').textContent = e.target.value;
  if (pitchShift) pitchShift.pitch = parseInt(e.target.value);
});
function adjustPitch(d) {
  const s = document.getElementById('pitchSlider');
  s.value = Math.max(-12, Math.min(12, parseInt(s.value) + d));
  s.dispatchEvent(new Event('input'));
}

/* ======== シャッフル ======== */
const toggleShuffle = () => {
  shuffle = !shuffle;
  document.getElementById('shuffleState').textContent = shuffle ? 'ON' : 'OFF';
};

/* ======== シーク ======== */
seekSlider.addEventListener('input', e => {
  if (!player || !player.buffer) return;
  const dest = parseFloat(e.target.value);
  ignoreStop = true;            // ★ 曲送り無効化
  player.stop();
  player.start(undefined, dest);
  player._startedAt = Tone.now() - dest;
  ignoreStop = false;           // ★ 復帰
  updateSeekBar();
});

/* ======== 再生制御 ======== */
async function loadAndPlay(idx) {
  if (isLoading) return;
  showLoading(true);
  stopAudio();

  currentIndex = idx;
  renderPlaylist();

  const buf = await Tone.context.decodeAudioData(await playlist[idx].arrayBuffer());

  pitchShift = new Tone.PitchShift({ pitch: parseInt(document.getElementById('pitchSlider').value) }).toDestination();
  player = new Tone.Player(buf).connect(pitchShift);
  player.volume.value = Tone.gainToDb(parseFloat(document.getElementById('volumeSlider').value));

  player.onstop = () => {              // ★ 曲が自然終了した時だけ nextTrack
    if (ignoreStop) return;            //   ← 手動停止時は無視
    nextTrack();
  };

  await Tone.start();
  if (Tone.context.state === 'suspended') await Tone.context.resume();

  player.start();
  player._startedAt = Tone.now();
  pausedOffset = 0;
  updateSeekBar();

  playStatus.textContent = '再生中...';
  playStatus.style.color = 'green';
  showLoading(false);
}
function playAudio() {
  if (!player) return;
  Tone.start().then(() => {
    if (Tone.context.state === 'suspended') Tone.context.resume();

    const startAt = pausedOffset;
    ignoreStop = true;
    player.start(undefined, startAt);
    player._startedAt = Tone.now() - startAt;
    ignoreStop = false;

    pausedOffset = 0;
    updateSeekBar();
    playStatus.textContent = '再生中...';
    playStatus.style.color = 'green';
  });
}
function pauseAudio() {
  if (player && player.state === 'started') {
    pausedOffset = Tone.now() - player._startedAt;
    ignoreStop = true;
    player.stop();
    ignoreStop = false;
    playStatus.textContent = '一時停止中';
    playStatus.style.color = 'orange';
    clearInterval(updateInterval);
  }
}
function stopAudio() {
  if (player) {
    ignoreStop = true;
    player.stop();
    ignoreStop = false;
    player.dispose();
    player = null;
  }
  if (pitchShift) { pitchShift.dispose(); pitchShift = null; }

  clearInterval(updateInterval);
  seekSlider.value = 0; seekSlider.max = 1;
  timeDisplay.textContent = '--:-- / --:--';
  pausedOffset = 0;
  playStatus.textContent = '停止中';
  playStatus.style.color = 'gray';
}
function nextTrack() {
  if (!playlist.length) return;
  const n = shuffle
    ? (playlist.length === 1 ? currentIndex : (() => { let r; do{r=Math.floor(Math.random()*playlist.length);}while(r===currentIndex); return r; })())
    : (currentIndex + 1) % playlist.length;
  loadAndPlay(n);
}

/* ======== シークバー表示 ======== */
function updateSeekBar() {
  if (!player || !player.buffer) return;
  clearInterval(updateInterval);

  const duration = player.buffer.duration;
  seekSlider.max = duration;

  const refresh = () => {
    const pos = Tone.now() - (player._startedAt || Tone.now());
    seekSlider.value = Math.min(pos, duration);
    timeDisplay.textContent = `${fmt(pos)} / ${fmt(duration)}`;
  };
  refresh();
  updateInterval = setInterval(refresh, 500);
}
  </script>
</body>
</html>
