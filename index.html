<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MP3 キーチェンジャー</title>
  <style>
    body { font-family: sans-serif; padding: 20px; margin-bottom: 80px; }
    h1 { font-size: 24px; }
    #playlist { margin-top: 10px; }
    .track { cursor: pointer; margin-bottom: 5px; }
    .track.selected { font-weight: bold; color: blue; }
    .controls, .sliders { margin-top: 20px; }
    input[type=range] { width: 100%; }
    .inline-label { display: flex; align-items: center; gap: 8px; }
    .status { margin-top: 10px; font-weight: bold; color: green; }
    .key-control-buttons { display: flex; gap: 8px; align-items: center; }
    .time-display { margin-top: 10px; font-size: 14px; color: #333; }
    .loading-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255,255,255,0.8); display: none;
      justify-content: center; align-items: center;
      font-size: 20px; font-weight: bold; color: #333;
      z-index: 9999;
    }
    footer { position: fixed; bottom: 0; left: 0; right: 0; background: #f2f2f2; padding: 10px 20px; border-top: 1px solid #ccc; text-align: center; font-size: 14px; color: #666; }
    @media (max-width: 600px) {
      body { padding: 10px; font-size: 16px; }
      h1 { font-size: 20px; }
      button { font-size: 16px; padding: 10px; width: 100%; margin-bottom: 10px; }
      .inline-label { flex-direction: column; align-items: flex-start; }
      input[type=range] { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">読み込み中...</div>
  <h1>クライアントサイド MP3 キーチェンジャー1.1</h1>
  <input type="file" id="fileInput" multiple accept="audio/mp3">
  <div id="playlist"></div>
  <div class="controls">
    <button onclick="playAudio()">再生</button>
    <button onclick="pauseAudio()">一時停止</button>
    <button onclick="stopAudio()">停止</button>
    <button onclick="nextTrack()">次の曲へ</button>
    <button onclick="toggleShuffle()">シャッフル: <span id="shuffleState">OFF</span></button>
    <div class="status" id="playStatus">未再生</div>
  </div>
  <div class="sliders">
    <label>音量調整:
      <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1">
    </label>
    <label class="inline-label">キー変更（半音）:
      <div class="key-control-buttons">
        <button onclick="adjustPitch(-1)">−</button>
        <input type="range" id="pitchSlider" min="-12" max="12" step="1" value="0">
        <button onclick="adjustPitch(1)">＋</button>
        <span id="pitchValue">0</span>
      </div>
    </label>
    <label>再生位置:
      <input type="range" id="seekSlider" min="0" max="1" step="0.01" value="0">
    </label>
    <div class="time-display" id="timeDisplay">--:-- / --:--</div>
  </div>
  <footer>
    クライアントサイドで安全に動作するMP3キーチェンジャー（β版）
  </footer>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.39/Tone.js"></script>
  <script>
    let playlist = [];
    let playOrder = [];
    let currentIndex = -1;
    let player = null;
    let pitchShift = null;
    let shuffle = false;
    let isLoading = false;
    let updateInterval = null;

    const playStatus = document.getElementById('playStatus');
    const timeDisplay = document.getElementById('timeDisplay');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const seekSlider = document.getElementById('seekSlider');

    function showLoading(show) {
      isLoading = show;
      loadingOverlay.style.display = show ? 'flex' : 'none';
    }

    document.getElementById('fileInput').addEventListener('change', (e) => {
      playlist = Array.from(e.target.files);
      playOrder = playlist.map((_, i) => i);
      renderPlaylist();
    });

    document.getElementById('volumeSlider').addEventListener('input', e => {
      if (player) player.volume.value = Tone.gainToDb(parseFloat(e.target.value));
    });

    document.getElementById('pitchSlider').addEventListener('input', e => {
      updatePitchDisplay();
      if (pitchShift) pitchShift.pitch = parseInt(e.target.value);
    });

    seekSlider.addEventListener('input', e => {
      if (player && player.buffer && player.buffer.duration) {
        const newTime = parseFloat(e.target.value) * player.buffer.duration;
        player.stop();
        player.start(undefined, newTime);
        updateSeekBar();
      }
    });

    function toggleShuffle() {
      shuffle = !shuffle;
      document.getElementById('shuffleState').textContent = shuffle ? 'ON' : 'OFF';
    }

    function nextTrack() {
      if (shuffle) {
        let next;
        do {
          next = Math.floor(Math.random() * playlist.length);
        } while (next === currentIndex && playlist.length > 1);
        loadAndPlay(next);
      } else {
        const nextIndex = (currentIndex + 1) % playlist.length;
        loadAndPlay(nextIndex);
      }
    }

    function updatePitchDisplay() {
      document.getElementById('pitchValue').textContent = document.getElementById('pitchSlider').value;
    }

    function adjustPitch(amount) {
      const slider = document.getElementById('pitchSlider');
      let newVal = parseInt(slider.value) + amount;
      newVal = Math.max(-12, Math.min(12, newVal));
      slider.value = newVal;
      updatePitchDisplay();
      if (pitchShift) pitchShift.pitch = newVal;
    }

    function renderPlaylist() {
      const list = document.getElementById('playlist');
      list.innerHTML = '';
      playlist.forEach((file, index) => {
        const div = document.createElement('div');
        div.textContent = file.name;
        div.className = 'track' + (index === currentIndex ? ' selected' : '');
        div.onclick = () => {
          loadAndPlay(index);
        };
        list.appendChild(div);
      });
    }

    async function loadAndPlay(index) {
      if (isLoading) return;
      showLoading(true);
      stopAudio();
      currentIndex = index;
      renderPlaylist();

      const file = playlist[index];
      const arrayBuffer = await file.arrayBuffer();
      const audioBuffer = await Tone.context.decodeAudioData(arrayBuffer);

      pitchShift = new Tone.PitchShift({ pitch: parseInt(document.getElementById('pitchSlider').value) }).toDestination();
      player = new Tone.Player({ url: audioBuffer, autostart: false }).connect(pitchShift);
      player.volume.value = Tone.gainToDb(parseFloat(document.getElementById('volumeSlider').value));

      player.onstop = () => {
        if (!isLoading) {
          nextTrack();
        }
      };

      await Tone.start();
      if (Tone.context.state === 'suspended') await Tone.context.resume();
      player.start();
      updateSeekBar();
      playStatus.textContent = '再生中...';
      playStatus.style.color = 'green';
      showLoading(false);
    }

    function playAudio() {
      if (isLoading || !player) return;
      Tone.start().then(() => {
        if (Tone.context.state === 'suspended') Tone.context.resume();
        player.start();
        updateSeekBar();
        playStatus.textContent = '再生中...';
        playStatus.style.color = 'green';
      });
    }

    function pauseAudio() {
      if (player && player.state === 'started') {
        player.stop();
        playStatus.textContent = '一時停止中';
        playStatus.style.color = 'orange';
      }
    }

    function stopAudio() {
      if (player) {
        player.stop();
        clearInterval(updateInterval);
        seekSlider.value = 0;
        timeDisplay.textContent = '--:-- / --:--';
        playStatus.textContent = '停止中';
        playStatus.style.color = 'gray';
        player.dispose();
        player = null;
      }
      if (pitchShift) {
        pitchShift.dispose();
        pitchShift = null;
      }
    }

    function updateSeekBar() {
      if (!player || !player.buffer || !player.buffer.duration) return;
      clearInterval(updateInterval);
      const duration = player.buffer.duration;
      updateInterval = setInterval(() => {
        const now = Tone.now();
        const elapsed = player._startTime ? now - player._startTime + (player._startOffset || 0) : 0;
        const progress = Math.min(elapsed / duration, 1);
        if (!isNaN(progress)) {
          seekSlider.value = progress;
          timeDisplay.textContent = formatTime(elapsed) + ' / ' + formatTime(duration);
        }
      }, 500);
    }

    function formatTime(seconds) {
      if (isNaN(seconds)) return '--:--';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return mins.toString().padStart(2, '0') + ':' + secs.toString().padStart(2, '0');
    }
  </script>
</body>
</html>
